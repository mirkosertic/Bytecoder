[
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-a/",
	"title": "The Command-Line Interface (CLI)",
	"tags": [],
	"description": "",
	"content": " Jump-Start Lets assume we have the following Java class, and we want to compile it to JavaScript and run it in the Browser:\npackage bytecodertest; public class HelloWorld { public static void main(String[] args) { System.out.println(\u0026quot;Hello World!\u0026quot;); } }  First of all, we need to compile the Java sources to a JVM class file. This is done by using the javac tool from the JDK:\nmkdir -p bytecodertest \u0026amp;\u0026amp; cd bytecodertest \u0026amp;\u0026amp; javac HelloWorld.java  The directry structure\n[root@host]# tree . ├── bytecoder-cli-2021-11-02-executable.jar └── bytecodertest └── HelloWorld.java  Now, we have the compiled .class files. Now we can use the Bytecoder CLI to compile it to JavaScript!\nStep 1: Download the CLI from Maven central:\nwget https://repo.maven.apache.org/maven2/de/mirkosertic/bytecoder/bytecoder-cli/2021-11-02/bytecoder-cli-2021-11-02-executable.jar  Step 2: Invoke the CLI and compile to JavaScript:\njava -jar bytecoder-cli-2021-11-02-executable.jar compile js -classpath=. -mainclass=bytecodertest.HelloWorld -builddirectory=.  Step 3: Create an embedding HTML document:\nNow we have a bytecoder.js file, which needs to be embedded into a HTML document. Here is a sample HTML file embedding the Bytecoder JavaScript and invoking it:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Bytecoder Test\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;bytecoder.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; bytecoder.exports.main(); console.log(\u0026quot;Done\u0026quot;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  After opening this HTML file in a Browser you will see the \u0026ldquo;Hello World!\u0026rdquo; output in the JavaScript console log.\nBonus: Compiling to WebAssembly\nGenerating WebAssembly output is just a command line switch.\njava -jar bytecoder-cli-2021-11-02-executable.jar -classpath=. -mainclass=bytecodertest.HelloWorld -builddirectory=. -backend=wasm -minify=false  Bytecoder\u0026rsquo;s WebAssembly backend can generate Wasm binaries without further third party software like wabt or binaryen.\n However, you need a different style of HTML embedding, which is shown here:\n\u0026lt;html\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;script src=\u0026quot;bytecoder.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; bytecoder.instantiate('lua_wasmwasmclasses.wasm').then(function() { console.log(\u0026quot;Bootstrapped\u0026quot;); bytecoder.instance.exports.main(null, bytecoder.instance.exports.newObjectArray(null, 0)); console.log(\u0026quot;Ready for action!\u0026quot;); }); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  The WebAssembly backend generates Wasm bytecoded based on the Exception-Handling and GC proposal. These features must be manually enabled in Chrome or Firefox as long as they have not been fully standardized.\n "
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-2/page-2-a/",
	"title": "Compiling OpenCL Kernels",
	"tags": [],
	"description": "",
	"content": " Compiling JVM Bytecode Kernels to OpenCL OpenCL Integration is highly experimental\n First of all, make sure to include the following dependencies:\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bytecoder.opencl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2021-11-02\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bytecoder-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2021-11-02\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependency\u0026gt;  Before we can use the OpenCL integration, we have to setup the whole OpenCL environment. An OpenCL environment can be obtained by the following code:\nimport de.mirkosertic.bytecoder.api.opencl.PlatformFactory; import de.mirkosertic.bytecoder.api.opencl.Platform; PlatformFactory theFactory = PlatformFactory.resolve(); Platform thePlatform = theFactory.createPlatform(logger,options);  The Platform instance must only be obtained once and can be cached.\nIf you have multiple GPUs or a system with NVIDIA Optimus technology, you have multiple OpenCL platform available. One for the NVIDIA GPU, and another for the embedded Intel GPU on your CPU. By default Bytecoder logs the available platforms at startup and selects the OpenCL platform with the highest number. If this does not fit, you can always add a OPENCL_PLATFORM=x to your JVM properties to set the OpenCL platform to number x.\nEvery OpenCL computation is done within an OpenCL Context. This context keeps references to compiled OpenCL programs and allocated memory per Kernel. It definitely makes sense to cache a created context. Closing and reopening of context instances forces the OpenCL runtime to recompile Kernels, which will cause a huge performance impact. Context instances are auto-closable, so they can be used with Java try-with-resource blocks.\nOpenCL Kernel instances are the workhorse of the system. They can be created by sub classing de.mirkosertic.bytecoder.api.opencl.Kernel and adding a single method to it. Here is a simple example of the whole workflow:\nPlatformFactory theFactory = PlatformFactory.resolve(); Platform thePlatform = theFactory.createPlatform(logger,options); final float[] theA = {10f, 20f, 30f, 40f}; final float[] theB = {100f, 200f, 300f, 400f}; final float[] theResult = new float[4]; try (Context theContext = thePlatform.createContext()) { theContext.compute(4, new Kernel() { public void processWorkItem() { int id = get_global_id(0); float a = theA[id]; float b = theB[id]; theResult[id] = a + b; } }); } for (int i=0; i\u0026lt;theResult.length;i++) { System.out.println(theResult[i]); }  This will print the numbers 110,220,330 and 440 at command line.\nHere is an example of the OpenCL C-Code generated for the Java Kernel from above:\n__kernel void BytecoderKernel(__global const float* val$theA, __global const float* val$theB, __global float* val$theResult) { int var1 = get_global_id(0); float var4 = val$theA[var1]; float var7 = val$theB[var1]; float var9 = var4 + var7; val$theResult[var1] = var9; return; }  "
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-3/page-3-a/",
	"title": "Intermediate Representation",
	"tags": [],
	"description": "",
	"content": "The Bytecoder internal intermediate representation is basically a directed graph. The key idea behind this is described in this paper.\nGiven this Java source code:\n@Test public void testSimpleLoop() { for (int i=0;i\u0026lt;10;i++) { } }  the following intermediate representation graph is generated (in its first, unoptimized form):\nThis graph combines data flow analysis and control flow into one big graph. Using this graph makes data and control flow dependencies explicit and lays foundation for a variety of optimizations that can be performed on it to either reduce code size or improve execution speed. Optimizing the program simply becomes an optimizing the graph problem.\nThe following graph shows the further optimized version of the previous loop:\nThere are two different output styles available for generated code:\n Relooper\nThe Relooper output generator tries to recover high level control flow constructs from the intermediate representation. This step eliminates the needs of GOTO statements and thus allows generation of more natural source code, which in turn can be easier read and optimized by Web Browsers or other tools. The Relooper supports all styles of control flows and also supports exception handling.\n Stackifier\n  The Stackifier is based on this paper. It tries to remove all GOTO statements and replaces them with structured control flow elements and multi level break and continues. The Stackifier does only work for reducible control flows and also does not support exception handling. The generated output is smaller and in some cases faster compared to the Relooper output.\nRelooper output is enabled by default for JS and Wasm backends. The Stackifier can be enabled for CLI or Maven by setting preferStackifier to true as a configuration parameter. If Stackifier is enabled and Bytecoder detects an irreducible control flow Relooper is used as a fallback.\nStackifier is used as the default by the OpenCL backend.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-a/",
	"title": "Java Box2D simulation",
	"tags": [],
	"description": "",
	"content": " A JBox2D simulation transpiled to JavaScript and WebAssembly JBox2D Demo compiled from Java to JavaScript JS Backend\nJBox2D Demo compiled from Java to WebAssembly Wasm Codegen\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-2/chapter-2-1/page-2-1-a/",
	"title": "Zoomable Mandelbrot set",
	"tags": [],
	"description": "",
	"content": " Mandelbrot set compiled to OpenCL   The following code will render a zoomable Mandelbrot set computed via OpenCL:\npublic class MandelbrotKernel extends Kernel { private final int maxIterations; private final int width; private final int height; private float x_min; private float y_min; private float x_max; private float y_max; private final int[] imageData; private float cellSize_width; private float cellSize_height; public MandelbrotKernel(final int aWidth, final int aHeight, final int aMaxIterations) { width = aWidth; height = aHeight; imageData = new int[width * height]; maxIterations = aMaxIterations; x_min = -2f; x_max = 2f; y_min = -1.5f; y_max = 1.5f; fitCellSize(); } private void fitCellSize() { cellSize_width = (x_max - x_min) / width; cellSize_height = (y_max - y_min) / height; } private int checkC(final float reC, final float imC) { float reZ=0,imZ=0,reZ_minus1=0,imZ_minus1=0; int i; for (i=0;i\u0026lt;maxIterations;i++) { imZ=2*reZ_minus1*imZ_minus1+imC; reZ=reZ_minus1*reZ_minus1-imZ_minus1*imZ_minus1+reC; if (reZ*reZ+imZ*imZ\u0026gt;4) return i; reZ_minus1=reZ; imZ_minus1=imZ; } return i; } @Override public void processWorkItem() { final int pixelIndex = get_global_id(0); final int x = pixelIndex % width; final int y = pixelIndex / width; final float reC = x_min + (x * cellSize_width); final float imC = y_min + (y * cellSize_height); imageData[pixelIndex] = checkC(reC, imC); } public int getMaxIterations() { return maxIterations; } public int getWidth() { return width; } public int getHeight() { return height; } public int[] getImageData() { return imageData; } public void zoomInOut(final int amount) { final float width = x_max - x_min; final float height = y_max - y_min; final float centerX = x_min + width / 2; final float centerY = y_min + height / 2; final float newHalfWidth = width * (1 + 0.05f * amount) / 2; final float newHalfHeight = height * (1 + 0.05f * amount) / 2; x_min = centerX - newHalfWidth; x_max = centerX + newHalfWidth; y_min = centerY - newHalfHeight; y_max = centerY + newHalfHeight; fitCellSize(); } public void focusOn(final int x, final int y) { final float halfWidth = (x_max - x_min) / 2; final float halfHeight = (y_max - y_min) / 2; final float newCenterX = x_min + x * cellSize_width; final float newCenterY = y_min + y * cellSize_height; x_min = newCenterX - halfWidth; x_max = newCenterX + halfWidth; y_min = newCenterY - halfHeight; y_max = newCenterY + halfHeight; } }  The full source code is available at GitHub.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/",
	"title": "Compiling JVM Bytecode",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Compiling JVM Bytecode to JavaScript or WebAssembly Here you will find some tutorials about compiling JVM Bytecode to JavaScript or WebAssembly.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-b/",
	"title": "The Maven Plugin",
	"tags": [],
	"description": "",
	"content": " Maven Plugin usage Bytecoder comes with a handy Maven plugin. This plugins supports the JavaScript and WebAssembly backends and can compile JVM Bytecode as part of the Maven project lifecycle without any third party or command-line tools.\nConfiguration options The following configuration options are available:\n buildDirectory': The build target directory. Defaults to${project.build.outputDirectory}`\n mainClass The Classname with the main class to be compiled. Required.\n backend: The Backend to be used. Can be js or wasm. Defaults to js.\n debugOutput: Shall debug output be generated? Defaults to false.\n optimizationLevel: Which kind of optimization should be applied? Can be DISABLED, DEFAULT or ALL. Defaults to DEFAULT.\n filenamePrefix: Prefix of the generated files. Defaults to bytecoder.\n additionalClassesToLink: List of full qualified class names to be linked beside the statically referenced ones to make them available by reflection API. Optional\n  Compiling to JavaScript \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bytecoder-mavenplugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2021-11-02\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;mainClass\u0026gt;de.mirkosertic.bytecoder.integrationtest.SimpleMainClass\u0026lt;/mainClass\u0026gt; \u0026lt;backend\u0026gt;js\u0026lt;/backend\u0026gt; \u0026lt;optimizationLevel\u0026gt;ALL\u0026lt;/optimizationLevel\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;compile\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;  You have to set a main class with a valid public static void main(String[] args) method as an entry point. The plugin will invoke the JavaScript compiler which will do all the heavy lifting. The generated JavaScript will be placed in the Maven target/bytecoder directory.\nCompiling to WebAssembly \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bytecoder-mavenplugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2021-11-02\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;mainClass\u0026gt;de.mirkosertic.bytecoder.integrationtest.SimpleMainClass\u0026lt;/mainClass\u0026gt; \u0026lt;backend\u0026gt;wasm\u0026lt;/backend\u0026gt; \u0026lt;optimizationLevel\u0026gt;ALL\u0026lt;/optimizationLevel\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;compile\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;  You have to set a main class with a valid public static void main(String[] args) method as an entry point. The plugin will invoke the WebAssembly compiler which will do all the heavy lifting. The generated WebAssembly text file and compiled binaries will be placed in the Maven target/bytecoder directory.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/",
	"title": "Bytecoder User Manual",
	"tags": [],
	"description": "",
	"content": " Bytecoder User Manual Introduction Bytecoder is a Rich Domain Model for Java Bytecode and Framework to interpret and transpile it to other languages such as JavaScript, OpenCL or WebAssembly.\nIts key features are:\n Ability to cross-compile JVM Bytecode to JavaScript, WebAssembly, OpenCL and other languages Primary compile targets are JavaScript and WebAssembly Work well with Debugger Toolchains and SourceMaps Use OpenJDK 17 as Java Classlib  The JVM Bytecode is parsed and transformed into an intermediate representation. This intermediate representation is passed thru optimizer stages and sent to a backend implementation for target code generation.\nThe JavaScript backend transforms the intermediate representation into JavaScript.\nThe WebAssembly backend transforms the intermediate representation into WebAssembly text and binary code.\nThe OpenCL backend is used to compile single algorithms into OpenCL and execute them on the GPU. This backend is designed to enhance existing programs running on the JVM to utilize the vast power of modern GPUs.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-b/",
	"title": "Kotlin JBox2D simulation",
	"tags": [],
	"description": "",
	"content": " A JBox2D/Kotlin simulation transpiled to JavaScript and WebAssembly JBox2D Demo compiled from Kotlin to JavaScript\nJBox2D Demo compiled from Kotlin to WebAssembly\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-2/chapter-2-1/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": " Example applications The following pages show you a set of example applications compiled with Bytecoder to OpenCL.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-2/",
	"title": "Using the OpenCL backend",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Compiling Java Kernels to OpenCL and use GPU acceleration Here we will show you how to write kernels in Java and compile them transparently to OpenCL kernels.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-c/",
	"title": "JRE Emulation",
	"tags": [],
	"description": "",
	"content": " JRE Emulation Bytecoder comes with a JRE emulation layer which is based on OpenJDK and also a set of additional libraries for browser interaction, vue.js and OpenCL integration.\nBytecoder comes with a set of JPMS modules like java.base etc. Please note that Bytecoder does not support the JPMS in general. From the compiler and runtime view, all classes are exported to the ALL-UNNAMED module by default, module-info declarations are completely ignored.\n bytecoder-core Bytecoder-core includes the compiler Logic and the JUnit Testrunner. Most of the time you won\u0026rsquo;t need this module directly, as it is included in the CLI and the Maven Plugin by default.\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bytecoder-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2021-11-02\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  bytecoder.api Bytecoder.api provides a set of Classes and Annotations which enables the Compiler do its job.\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bytecoder.api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2021-11-02\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  java.base Java.base contains the java.base JPMS Module.\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;java.base\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2021-11-02\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  java.logging Java.base contains the java.logging JPMS Module.\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;java.logging\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2021-11-02\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  java.xml Java.xml contains the java.xml JPMS Module.\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;java.xml\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2021-11-02\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  java.datatransfer Java.datatransfer contains the java.datatransfer JPMS Module.\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;java.datatransfer\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2021-11-02\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  java.desktop Java.desktop contains the java.desktop JPMS Module.\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;java.desktop\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2021-11-02\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  bytecoder.web Bytecoder.web contains APIs to interact with the Browser.\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bytecoder.web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2021-11-02\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  bytecoder.vue Bytecoder.vue allows vue.js enabled frontends using Bytecoder.\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bytecoder.vue\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2021-11-02\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  bytecoder.opencl Bytecoder.opencl is required if you want to use the OpenCL integration.\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bytecoder.opencl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2021-11-02\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  "
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-c/",
	"title": "Lua4J interpreter",
	"tags": [],
	"description": "",
	"content": " The Lua4J interpreter transpiled to JavaScript and WebAssembly Lua4J Demo compiled to JavaScript\nLua4J Demo compiled to WebAssembly\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-3/",
	"title": "Internals",
	"tags": [],
	"description": "",
	"content": " Chapter 4 Implementation internals Here you will find a lot of information about what is going on behind the scenes of Bytecoder.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-d/",
	"title": "Reflection API",
	"tags": [],
	"description": "",
	"content": " Overview Reflection support is currently reengineered. This chapter might be outdated and will be rewritten when work is complete.\n Bytecoder is an AOT (Ahead-of-time) compiler. As this, it has to determine the set of classes at compile time. It does this by running a statical dependency analysis which starts at a class implementing a public static void main(String[] args) method and builds a dependency tree from there resulting in the final set of classes and methods that must be included to make the program valid.\nHowever, things start to get tricky once we use the Java Reflection API.\nThe most famous part of the Reflection API is the Class.forName method and its derivatives. Here, the class to be resolved is defined as runtime. This is a problem for an AOT compiler. Bytecoder tries so solve this problem using a set of heuristics and configuration.\nClasses that are very likely to be resolved by reflection are automatically included by the compiler. Some prominent examples are implementations of java.nio.charset.Charset or java.lang.CharacterData. There is also a compiler option available by the CLI or Maven Plugin to add additional classes.\nOnly zero-arg constructors are supported yet.\n Support for the Java Reflection API Supported by all backends The following APIs are supported by Bytecoder by all backends:\nClass runtimeClass = Class.forName(\u0026quot;FullQualifiedClassNameHere\u0026quot;); Object instance = runtimeClass.newInstance(); // Method 1 to instantiate a class cl.getConstructor(new Class[0]).newInstance(); // Method 2 to instantiate a class  Additional support for JavaScript and Wasm backend The JavaScript and Wasm backends provide support for reflective field access:\nField fields[] = ReflectionTarget.class.getDeclaredFields(); Field f = BaseClass.class.getField(\u0026quot;staticField\u0026quot;); // Get field by name f.getName(); // Retrieve field name f.getModifiers(); // Retrieve modifiers f.get(BaseClass.class); // Get static or instance value f.put(BaseClass.class, \u0026quot;newvalue\u0026quot;); // Put static or instance value Class.isPrimitive() // Check if the class represents a primitive value  Reflection/AOT configuration for all compiler backends Classes available to the reflection API can be configured by placing a bytecoder-reflection.json file into the root of the classpath. The syntax of the configuration file is shown in the follwing example:\n{ \u0026quot;sun.nio.cs.UTF_8\u0026quot;: { // The full-qualified class name is used as a key here // Please note that you have to include subclasses // and innerclasses of this class explicitly \u0026quot;enableClassForName\u0026quot;: true // The class is available by Class.forName() // This also includes reflective read and write // field access for all declared fields }, }  The ServiceLocator API is currently not supported!\n "
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-d/",
	"title": "Vue.js WebAssembly integration",
	"tags": [],
	"description": "",
	"content": " An example showing vue.js and WebAssembly integration vue.js integration Demo compiled to WebAssembly\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-e/",
	"title": "Gamecomposer Gameengine",
	"tags": [],
	"description": "",
	"content": " A complex gameengine compiled to JavaScript and WebAssembly GameComposer Physics Game Example compiled to WebAssembly. GameComposer is available here\nGameComposer Physics Game Example compiled to JavaScript. GameComposer is available here\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-f/",
	"title": "Interoperability",
	"tags": [],
	"description": "",
	"content": " Hello World, extended edition! Let\u0026rsquo;s see how a simple Java program can be written that changes the document title in the Browser. Here it is:\nimport de.mirkosertic.bytecoder.api.web.Event; import de.mirkosertic.bytecoder.api.web.EventListener; import de.mirkosertic.bytecoder.api.web.HTMLDocument; import de.mirkosertic.bytecoder.api.web.Window; public class OpaqueReferenceTest { public static void main(String[] args) { final Window w = Window.window(); w.document().addEventListener(\u0026quot;click\u0026quot;, new EventListener\u0026lt;ClickEvent\u0026gt;() { @Override public void run(final ClickEvent aValue) { w.document().title(\u0026quot;clicked!\u0026quot;); } }); } }  I\u0026rsquo;ll try to explain the basics behind this and how it can be compiled to JavaScript or WebAssembly in the following sections.\nInteroperability and runtime linkage Programs do not live on their own, they need to communicate with their environment. This communication can be tricky if done on multiple environments. Bytecoder supports JavaScript, WebAssembly and OpenCL as target platforms. How does this wok?\nOpaqueReferenceTypes API Bytecoder allows transparent usage of APIs not implemented by Bytecoder itself. Such APIs are provided by the host environment, for instance the DOM API or interaction with the browser window. Bytecoder support such APIs by so called OpaqueReferenceTypes. For every external API, a new OpaqueReferenceType in form of a JVM interface class needs to be created. Bytecoder already comes with implementations for the browser window and the DOM.\nSee the following example, which demonstrates calls from Bytecoder to the HTML Canvas API:\nWindow window = Window.window(); Document document = window.document(); final HTMLCanvasElement theCanvas = document.getElementById(\u0026quot;benchmark-canvas\u0026quot;); CanvasRenderingContext2D renderingContext2D = theCanvas.getContext(\u0026quot;2d\u0026quot;); renderingContext2D.moveTo(10, 10); renderingContext2D.lineTo(20, 20);  Bytecoder also supports event listeners, as seen in the following example:\nfinal HTMLElement button = document.getElementById(\u0026quot;button\u0026quot;); button.addEventListener(\u0026quot;click\u0026quot;, new EventListener\u0026lt;ClickEvent\u0026gt;() { @Override public void run(ClickEvent aValue) { button.disabled = true; } });  The OpaqueReferenceType API allows the following types for Bytecoder-Host communication:\n Primitives(int,float,double,long,char,byte,short) java.lang.String de.mirkosertic.bytecoder.api.OpaqueReferenceType and sub classes of it de.mirkosertic.bytecoder.api.Callback and sub classes of it  java.lang.String references are a special case. They are objects in the sense of the JVM, but they are not automatically converted to JavaScript String instances on host side due to the expensive conversion operation and its potential performance impact. However, there are handy conversion operations available to do it if its really needed. The conversion functions are part of the global bytecoder object as bytecoder.toJSString(aBytecoderString) and bytecoder.toBytecoderString(aJSString) respectively.\n The JVM long and double datatypes are currently only available in a limited form in Bytecoder. Bytecoder is limited to a 53-bit range due to JavaScript\u0026rsquo;s IEEE 754 double precision number type. However, once JavaScript BigInt will be supported by all major browsers, Bytecoder will use BigInt as a substitute for the JVM long datatype. 64-bit Datatypes such as long or double are only supported without precision loss by the WebAssembly wasm backend. Please note there is a loss in precisison when passing a double from WebAssembly to JS (calling an imported function).\n Importing functionality from the host environment Using host environment functionality is quite common. This can be either simply logging or more complex code. Basically something that cannot be archived by plain OpaqueReferenceTypes.\nJava has a built-in language feature for importing functionality. The native keyword!\nFor instance, we take a look at the TMath runtime class:\npublic class TMath extends TObject { public static native double sqrt(double aValue); }  The native keyword instructs the JVM to link the implementation code from somewhere else. This linking is done when bootstrapping the Bytecoder runtime. By default, Bytecoder will import the implementation using a modulename and an importname. The modulename is derived from the classname in lowercase, the importname is the method name to import.\nNative-Linking in JavaScript At startup, the following code must be provided:\nbytecoder.imports.math = { sqrtDOUBLE: function(p1) { return Math.sqrt(p1); }, };  Native-Linking in WebAssembly At startup, the following code must be provided:\nbytecoder.imports.math = { sqrtDOUBLE: function(thisref, p1) { return Math.sqrt(p1); }, };  Customizing the module names Sometimes you want to provide your own modulename and importname. This can be done by adding an @de.mirkosertic.bytecoder.api.Import annotation to the native method:\npublic class CanvasRenderingContext2D { @Import(module = \u0026quot;canvas\u0026quot;, name = \u0026quot;canvasClear\u0026quot;) public native void clear(); }  Exporting functionality to the host environment We also want to make functionality be callable from the host environment. The most important use case for this is to call out program! So, how can this be done? Java has no keyword that could mimic this behavior, so we have to provide our own. Method that should be callable from the host environment needs to be annotated with @de.mirkosertic.bytecoder.api.Export, as seen in the following example:\npublic class JBox2DSimulation { @Export(\u0026quot;proceedSimulation\u0026quot;) public static void proceedSimulation() { } }  Calling exported functionality from JavaScript Just call an exported method using the Bytecoder module API:\nbytecoder.exports.proceedSimulation();  Calling exported functionality from WebAssembly Easy, just call the method:\nrunningInstance.exports.proceedSimulation(0);  The WebAssembly runtime only makes @de.mirkosertic.bytecoder.api.Export annotated methods available as exports.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-e/",
	"title": "Unit Testing",
	"tags": [],
	"description": "",
	"content": " Testing code generation Bytecoder comes with built in JUnit Testing support using a specialized test runner. This test runner compiles the body of the test method to a target language and executes this code. For instance, the following JUnit Test\n@RunWith(de.mirkosertic.bytecoder.core.test.UnitTestRunner.class) public class SimpleMathTest { public static int sum(int a, int b) { return a + b; } @Test public void testAdd() throws Exception { int c = sum(10, 20); Assert.assertEquals(20, c, 0); } }  is compiled to JavaScript and WebAssembly and executed using Selenium. The test runner also supports comparison of original Java code and its cross compiled counterpart. This mechanism is the core tool to test the compiler and the Classlib.\nYou don\u0026rsquo;t need to install the right Chrome version and Selenium drivers as Bytecoder uses Testcontainers to run everything. All you need is a working Docker environment as described here.\nPlease make sure to include the following dependency to make the test runner working:\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bytecoder-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2021-11-02\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependency\u0026gt;  "
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-g/",
	"title": "Extending the JRE",
	"tags": [],
	"description": "",
	"content": " Extending existing classes Sometimes the methods or properties you want aren\u0026rsquo;t there, but it\u0026rsquo;s very simple to add them.\npublic abstract class CustomCanvas extends de.mirkosertic.bytecoder.api.web.HTMLCanvasElement { // The following two methods are setters and getters for the canvas.width property. @de.mirkosertic.bytecoder.api.OpaqueProperty public abstract void width(float value); @de.mirkosertic.bytecoder.api.OpaqueProperty public abstract float width(); }  To use your custom methods or properties simply cast a HTMLCanvasElement to CustomCanvas.\n((CustomCanvas) Window.window().document().getElementById(\u0026quot;canvas\u0026quot;)).width(1000);  Implementing bridges for JavaScript objects and classes Explanation of JavaScript data types in this page:\n Objects are non-instantiatable (e.g. window.navigator) Classes are instantiable (e.g. new ArrayBuffer(\u0026hellip;))  Objects public abstract class Navigator implements de.mirkosertic.bytecoder.api.OpaqueReferenceType { public static native Navigator navigator(); @de.mirkosertic.bytecoder.api.OpaqueProperty public abstract String userAgent(); @de.mirkosertic.bytecoder.api.OpaqueProperty public abstract boolean cookieEnabled(); // If you want to have a different name in the Java code, you can // name the method for example beaconSend and annotate it with // @OpaqueMethod(\u0026quot;sendBeacon\u0026quot;) // This specific method has more types of possible arguments, // if you need to support those you just need to add more methods // but with the other `data` types public abstract void sendBeacon(String url, String data); }  // Although the import would be created because this // class is implementing OpaqueReferenceType AND we are // calling one of it's abstract methods in our Java code, // not calling one would cause JavaScript errors. // So to be 100% sure it's better to define fallback to an // empty object. bytecoder.imports.navigator = bytecoder.imports.navigator || {}; // This method has no arguments so it's simply called navigator bytecoder.imports.navigator.navigator = function (thisref) { return bytecoder.toBytecoderReference(navigator); };  System.out.println(Navigator.navigator().userAgent());  Classes public abstract class ArrayBuffer implements OpaqueReferenceType { // The @Import annotation is completely optional and // it removes the need for having to include the // parameter types in the method name on the JavaScript side. @de.mirkosertic.bytecoder.api.Import(module = \u0026quot;arraybuffer\u0026quot;, name = \u0026quot;create\u0026quot;) public static native create(int size); @de.mirkosertic.bytecoder.api.OpaqueProperty public int byteLength(); }  // Read the comment on Objects in this section. // Native methods are not abstract and if we for example // only call ArrayBuffer.create(...) then an import would not // be created. But if we also called ArrayBuffer.byteLength() // it would, so it is much more secure to fallback to {}. bytecoder.imports.arraybuffer = bytecoder.imports.arraybuffer || {}; // Passing around objects works by references, the Java code // automatically converts this reference to an instance of // ArrayBuffer but the JavaScript bindings have no such features. // Warning: This method uses the @Import annotation which is why // it is called `create` and not `createINT`. bytecoder.imports.arraybuffer.create = function (thisref, size) { return bytecoder.toBytecoderReference(new ArrayBuffer(size)); };  System.out.println(ArrayBuffer.create(6).byteLength()); // 6  Taking classes as method parameters public abstract class DataView implements de.mirkosertic.bytecoder.api.OpaqueReferenceType { public static native create(ArrayBuffer arrayBuffer); // ... opaque methods and properties ... }  bytecoder.imports.dataview = bytecoder.imports.dataview || {}; // create - method name, ArrayBuffer - parameter type bytecoder.imports.dataview.createArrayBuffer = function (thisref, arraybufferref) { return bytecoder.toBytecoderReference(new DataView(bytecoder.toJSReference(arraybufferref))); };  Import and Export semantics  Imports are methods imported from JavaScript/Host side and called from Java. Exports are methods exported from Java and called from JavaScript/Host side.  Emulating classes and methods Bytecoder is based on the OpenJDK JRE classlib. However, it is sometimes necessary to patch existing classes to make them compatible with Bytecoder.\nBytecoder introduces a concept called shadow types for this purpose.\nTake a look at the java.lang.System class. It needs some adaptation for make it compatible with Bytecoder. Now, the shadow type called de.mirkosertic.bytecoder.classlib.java.lang.TSystem is introduced. Shadow types need the package prefix de.mirkosertic.bytecoder.classlib and the @de.mirkosertic.bytecoder.api.SubstitutesInClass annotation.\n@SubstitutesInClass toggles what should be adapted by the shadow type. It can either override the whole class by setting completeReplace=true or only specified methods by setting completeReplace=false.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": " Example applications The following pages show you a set of example applications compiled with Bytecoder to JavaScript or WebAssembly.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]
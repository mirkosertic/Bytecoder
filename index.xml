<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bytecoder User Manual on Bytecoder - JVM to JavaScript, OpenCL and WebAssembly Transpiler</title>
    <link>https://mirkosertic.github.io/Bytecoder/</link>
    <description>Recent content in Bytecoder User Manual on Bytecoder - JVM to JavaScript, OpenCL and WebAssembly Transpiler</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 28 Mar 2023 00:00:00 +0200</lastBuildDate>
    
	<atom:link href="https://mirkosertic.github.io/Bytecoder/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>The Command-Line Interface (CLI)</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-a/</link>
      <pubDate>Mon, 30 Jan 2023 00:00:00 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-a/</guid>
      <description>Jump-Start Lets assume we have the following Java class, and we want to compile it to JavaScript and run it in the Browser:
package bytecodertest; public class HelloWorld { public static void main(String[] args) { System.out.println(&amp;quot;Hello World!&amp;quot;); } }  First of all, we need to compile the Java sources to a JVM class file. This is done by using the javac tool from the JDK:
mkdir -p bytecodertest &amp;amp;&amp;amp; cd bytecodertest &amp;amp;&amp;amp; javac HelloWorld.</description>
    </item>
    
    <item>
      <title>Compiling OpenCL Kernels</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-2/page-2-a/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-2/page-2-a/</guid>
      <description>Compiling JVM Bytecode Kernels to OpenCL OpenCL Integration is highly experimental
 First of all, make sure to include the following dependencies:
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;de.mirkosertic.bytecoder&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;bytecoder.opencl&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2023-05-19&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;de.mirkosertic.bytecoder&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;bytecoder-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2023-05-19&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependency&amp;gt;  Before we can use the OpenCL integration, we have to setup the whole OpenCL environment. An OpenCL environment can be obtained by the following code:
import de.mirkosertic.bytecoder.api.opencl.PlatformFactory; import de.mirkosertic.bytecoder.api.opencl.Platform; PlatformFactory theFactory = PlatformFactory.resolve(); Platform thePlatform = theFactory.</description>
    </item>
    
    <item>
      <title>Intermediate Representation</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-3/page-3-a/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-3/page-3-a/</guid>
      <description>The Bytecoder internal intermediate representation is basically a directed graph. The key idea behind this is described in this paper.
Given this Java source code:
@Test public void testSimpleLoop() { int x = 0; for (int i = 0; i &amp;lt; 100; i++) { x = x + i; } }  the following intermediate representation graph is generated (in its first, unoptimized form):
This graph combines data flow analysis and control flow into one big graph.</description>
    </item>
    
    <item>
      <title>Java Box2D simulation</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-a/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-a/</guid>
      <description>A JBox2D simulation transpiled to JavaScript and WebAssembly JBox2D Demo compiled from Java to JavaScript JS Backend
JBox2D Demo compiled from Java to WebAssembly Wasm Codegen</description>
    </item>
    
    <item>
      <title>Zoomable Mandelbrot set</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-2/chapter-2-1/page-2-1-a/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-2/chapter-2-1/page-2-1-a/</guid>
      <description>Mandelbrot set compiled to OpenCL   The following code will render a zoomable Mandelbrot set computed via OpenCL:
public class MandelbrotKernel extends Kernel { private final int maxIterations; private final int width; private final int height; private float x_min; private float y_min; private float x_max; private float y_max; private final int[] imageData; private float cellSize_width; private float cellSize_height; public MandelbrotKernel(final int aWidth, final int aHeight, final int aMaxIterations) { width = aWidth; height = aHeight; imageData = new int[width * height]; maxIterations = aMaxIterations; x_min = -2f; x_max = 2f; y_min = -1.</description>
    </item>
    
    <item>
      <title>The Maven Plugin</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-b/</link>
      <pubDate>Mon, 30 Jan 2023 00:00:00 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-b/</guid>
      <description>Maven Plugin usage Bytecoder comes with a handy Maven plugin. This plugins supports the JavaScript and WebAssembly backends and can compile JVM Bytecode as part of the Maven project lifecycle without any third party or command-line tools.
Configuration options The following configuration options are available:
 buildDirectory&#39;: The build target directory. Defaults to${project.build.outputDirectory}`
 mainClass The Classname with the main class to be compiled. Required.
 backend: The Backend to be used.</description>
    </item>
    
    <item>
      <title>Kotlin JBox2D simulation</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-b/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-b/</guid>
      <description>A JBox2D/Kotlin simulation transpiled to JavaScript and WebAssembly JBox2D Demo compiled from Kotlin to JavaScript
JBox2D Demo compiled from Kotlin to WebAssembly</description>
    </item>
    
    <item>
      <title>JRE Emulation</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-c/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-c/</guid>
      <description>JRE Emulation Bytecoder comes with a JRE emulation layer which is based on OpenJDK and also a set of additional libraries for browser interaction, vue.js and OpenCL integration.
Bytecoder comes with a set of JPMS modules like java.base etc. Please note that Bytecoder does not support the JPMS in general. From the compiler and runtime view, all classes are exported to the ALL-UNNAMED module by default, module-info declarations are completely ignored.</description>
    </item>
    
    <item>
      <title>Lua4J interpreter</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-c/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-c/</guid>
      <description>The Lua4J interpreter transpiled to JavaScript and WebAssembly Lua4J Demo compiled to JavaScript
Lua4J Demo compiled to WebAssembly</description>
    </item>
    
    <item>
      <title>Reflection API</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-d/</link>
      <pubDate>Mon, 11 Jan 2021 00:00:00 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-d/</guid>
      <description>Overview Reflection support is currently reengineered. This chapter might be outdated and will be rewritten when work is complete.
 Bytecoder is an AOT (Ahead-of-time) compiler. As this, it has to determine the set of classes at compile time. It does this by running a statical dependency analysis which starts at a class implementing a public static void main(String[] args) method and builds a dependency tree from there resulting in the final set of classes and methods that must be included to make the program valid.</description>
    </item>
    
    <item>
      <title>Vue.js WebAssembly integration</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-d/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-d/</guid>
      <description>An example showing vue.js and WebAssembly integration vue.js integration Demo compiled to WebAssembly</description>
    </item>
    
    <item>
      <title>Gamecomposer Gameengine</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-e/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-e/</guid>
      <description>A complex gameengine compiled to JavaScript and WebAssembly GameComposer Physics Game Example compiled to WebAssembly. GameComposer is available here
GameComposer Physics Game Example compiled to JavaScript. GameComposer is available here</description>
    </item>
    
    <item>
      <title>Interoperability</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-f/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-f/</guid>
      <description>Hello World, extended edition! Let&amp;rsquo;s see how a simple Java program can be written that changes the document title in the Browser. Here it is:
import de.mirkosertic.bytecoder.api.web.Event; import de.mirkosertic.bytecoder.api.web.EventListener; import de.mirkosertic.bytecoder.api.web.HTMLDocument; import de.mirkosertic.bytecoder.api.web.Window; public class OpaqueReferenceTest { public static void main(String[] args) { final Window w = Window.window(); w.document().addEventListener(&amp;quot;click&amp;quot;, new EventListener&amp;lt;ClickEvent&amp;gt;() { @Override public void run(final ClickEvent aValue) { w.document().title(&amp;quot;clicked!&amp;quot;); } }); } }  I&amp;rsquo;ll try to explain the basics behind this and how it can be compiled to JavaScript or WebAssembly in the following sections.</description>
    </item>
    
    <item>
      <title>Unit Testing</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-e/</link>
      <pubDate>Mon, 16 Dec 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-e/</guid>
      <description>Testing code generation Bytecoder comes with built in JUnit Testing support using a specialized test runner. This test runner compiles the body of the test method to a target language and executes this code. For instance, the following JUnit Test
@RunWith(de.mirkosertic.bytecoder.core.test.UnitTestRunner.class) public class SimpleMathTest { public static int sum(int a, int b) { return a + b; } @Test public void testAdd() throws Exception { int c = sum(10, 20); Assert.</description>
    </item>
    
    <item>
      <title>Extending the JRE</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-g/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-g/</guid>
      <description>Extending existing classes Sometimes the methods or properties you want aren&amp;rsquo;t there, but it&amp;rsquo;s very simple to add them.
public abstract class CustomCanvas extends de.mirkosertic.bytecoder.api.web.HTMLCanvasElement { // The following two methods are setters and getters for the canvas.width property. @de.mirkosertic.bytecoder.api.OpaqueProperty public abstract void width(float value); @de.mirkosertic.bytecoder.api.OpaqueProperty public abstract float width(); }  To use your custom methods or properties simply cast a HTMLCanvasElement to CustomCanvas.
((CustomCanvas) Window.window().document().getElementById(&amp;quot;canvas&amp;quot;)).width(1000);  Implementing bridges for JavaScript objects and classes Explanation of JavaScript data types in this page:</description>
    </item>
    
  </channel>
</rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bytecoder User Manual on Bytecoder - JVM to JavaScript and WebAssembly Transpiler</title>
    <link>https://mirkosertic.github.io/Bytecoder/</link>
    <description>Recent content in Bytecoder User Manual on Bytecoder - JVM to JavaScript and WebAssembly Transpiler</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 25 Oct 2019 14:42:16 +0200</lastBuildDate>
    
	<atom:link href="https://mirkosertic.github.io/Bytecoder/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>The Command-Line Interface (CLI)</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-a/</link>
      <pubDate>Fri, 22 Nov 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-a/</guid>
      <description>Jump-Start Lets assume we have the following Java class, and we want to compile it to JavaScript and run it in the Browser:
package bytecodertest; public class HelloWorld { public static void main(String[] args) { System.out.println(&amp;quot;Hello World!&amp;quot;); } }  First of all, we need to compile the Java sources to a JVM class file. This is done by using the javac tool from the JDK:
javac HelloWorld.java  Now, we have the compiled .</description>
    </item>
    
    <item>
      <title>Compiling OpenCL Kernels</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-2/page-2-a/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-2/page-2-a/</guid>
      <description>Compiling JVM Bytecode Kernels to OpenCL OpenCL Integration is highly experimental
 First of all, make sure to include the following dependencies:
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;de.mirkosertic.bytecoder&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;bytecoder.opencl&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2021-01-26&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;de.mirkosertic.bytecoder&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;bytecoder-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2021-01-26&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependency&amp;gt;  Before we can use the OpenCL integration, we have to setup the whole OpenCL environment. An OpenCL environment can be obtained by the following code:
import de.mirkosertic.bytecoder.api.opencl.PlatformFactory; import de.mirkosertic.bytecoder.api.opencl.Platform; PlatformFactory theFactory = PlatformFactory.resolve(); Platform thePlatform = theFactory.</description>
    </item>
    
    <item>
      <title>Intermediate Representation</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-3/page-3-a/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-3/page-3-a/</guid>
      <description>The Bytecoder internal intermediate representation is basically a directed graph. The key idea behind this is described in this paper.
Given this Java source code:
@Test public void testSimpleLoop() { for (int i=0;i&amp;lt;10;i++) { } }  the following intermediate representation graph is generated (in its first, unoptimized form):
This graph combines data flow analysis and control flow into one big graph. Using this graph makes data and control flow dependencies explicit and lays foundation for a variety of optimizations that can be performed on it to either reduce code size or improve execution speed.</description>
    </item>
    
    <item>
      <title>Java Box2D simulation</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-a/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-a/</guid>
      <description>A JBox2D simulation transpiled to JavaScript and WebAssembly JBox2D Demo compiled from Java to JavaScript Relooper Codegen vs. Stackifier Codegen
JBox2D Demo compiled from Java to WebAssembly Relooper Codegen vs. Stackifier Codegen
JBox2D Demo compiled from Java to WebAssembly with LLVM Codegen</description>
    </item>
    
    <item>
      <title>Zoomable Mandelbrot set</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-2/chapter-2-1/page-2-1-a/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-2/chapter-2-1/page-2-1-a/</guid>
      <description>Mandelbrot set compiled to OpenCL   The following code will render a zoomable Mandelbrot set computed via OpenCL:
public class MandelbrotKernel extends Kernel { private final int maxIterations; private final int width; private final int height; private float x_min; private float y_min; private float x_max; private float y_max; private final int[] imageData; private float cellSize_width; private float cellSize_height; public MandelbrotKernel(final int aWidth, final int aHeight, final int aMaxIterations) { width = aWidth; height = aHeight; imageData = new int[width * height]; maxIterations = aMaxIterations; x_min = -2f; x_max = 2f; y_min = -1.</description>
    </item>
    
    <item>
      <title>Kotlin JBox2D simulation</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-b/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-b/</guid>
      <description>A JBox2D/Kotlin simulation transpiled to JavaScript and WebAssembly JBox2D Demo compiled from Kotlin to JavaScript
JBox2D Demo compiled from Kotlin to WebAssembly</description>
    </item>
    
    <item>
      <title>The Maven Plugin</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-b/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-b/</guid>
      <description>Maven Plugin usage Bytecoder comes with a handy Maven plugin. This plugins supports the JavaScript and WebAssembly backends and can compile JVM Bytecode as part of the Maven project lifecycle without any third party or command-line tools.
Configuration options The following configuration options are available:
 buildDirectory&#39;: The build target directory. Defaults to${project.build.outputDirectory}`
 mainClass The Classname with the main class to be compiled. Required.
 backend: The Backend to be used.</description>
    </item>
    
    <item>
      <title>WebAssembly Memory Management</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-3/page-3-b/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-3/page-3-b/</guid>
      <description>The WebAssembly backend emulates high level data types using WebAssembly primitives. At the moment only i32 and f32 types. All other data types are composed using data blocks in the linear memory and pointers, which are basically also i32. This Backend does not use Wasm64.
Memory The memory is managed. It is dynamically allocated and automatically freed using a Mark-and-Sweep garbage collector. All memory is directly mapped to the Wasm linear memory.</description>
    </item>
    
    <item>
      <title>JRE Emulation</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-c/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-c/</guid>
      <description>JRE Emulation Bytecoder comes with a JRE emulation layer which is based on OpenJDK and also a set of additional libraries for browser interaction, vue.js and OpenCL integration.
Bytecoder comes with a set of JPMS modules like java.base etc. Please note that Bytecoder does not support the JPMS in general. From the compiler and runtime view, all classes are exported to the ALL-UNNAMED module by default, module-info declarations are completely ignored.</description>
    </item>
    
    <item>
      <title>Lua4J interpreter</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-c/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-c/</guid>
      <description>The Lua4J interpreter transpiled to JavaScript and WebAssembly Lua4J Demo compiled to JavaScript
Lua4J Demo compiled to WebAssembly
Lua4J Demo compiled to WebAssembly with LLVM</description>
    </item>
    
    <item>
      <title>Optimizer effectiveness</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-3/page-3-c/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-3/page-3-c/</guid>
      <description>Step JBox2D JS Demo JBox2D Wasm Demo     Unoptimized 2.051.489 bytes 1.226.186 bytes   Linear Register Allocation 1.582.659 bytes 1.081.372 bytes   Constant Inlining 1.487.327 bytes 1.010.403 bytes   Inefficient If-Conditions 1.473.286 bytes 1.001.294 bytes   Inefficient Field-Read 1.401.204 bytes 929.177 bytes   Inefficient Field-Write 1.370.353 bytes 909.742 bytes   Inefficient Invocations 1.261.180 bytes 857.123 bytes   Inefficient Array-Access 1.</description>
    </item>
    
    <item>
      <title>Reflection API</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-d/</link>
      <pubDate>Mon, 11 Jan 2021 00:00:00 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-d/</guid>
      <description>Overview Bytecoder is an AOT (Ahead-of-time) compiler. As this, it has to determine the set of classes at compile time. It does this by running a statical dependency analysis which starts at a class implementing a public static void main(String[] args) method and builds a dependency tree from there resulting in the final set of classes and methods that must be included to make the program valid.
However, things start to get tricky once we use the Java Reflection API.</description>
    </item>
    
    <item>
      <title>Vue.js WebAssembly integration</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-d/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-d/</guid>
      <description>An example showing vue.js and WebAssembly integration vue.js integration Demo compiled to WebAssembly
vue.js integration Demo compiled to WebAssembly with LLVM</description>
    </item>
    
    <item>
      <title>Gamecomposer Gameengine</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-e/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/chapter-1-1/page-1-1-e/</guid>
      <description>A complex gameengine compiled to JavaScript and WebAssembly GameComposer Physics Game Example compiled to WebAssembly. GameComposer is available here
GameComposer Physics Game Example compiled to JavaScript. GameComposer is available here</description>
    </item>
    
    <item>
      <title>Interoperability</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-f/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-f/</guid>
      <description>Hello World, extended edition! Let&amp;rsquo;s see how a simple Java program can be written that changes the document title in the Browser. Here it is:
import de.mirkosertic.bytecoder.api.web.Event; import de.mirkosertic.bytecoder.api.web.EventListener; import de.mirkosertic.bytecoder.api.web.HTMLDocument; import de.mirkosertic.bytecoder.api.web.Window; public class OpaqueReferenceTest { public static void main(String[] args) { final Window w = Window.window(); w.document().addEventListener(&amp;quot;click&amp;quot;, new EventListener&amp;lt;ClickEvent&amp;gt;() { @Override public void run(final ClickEvent aValue) { w.document().title(&amp;quot;clicked!&amp;quot;); } }); } }  I&amp;rsquo;ll try to explain the basics behind this and how it can be compiled to JavaScript or WebAssembly in the following sections.</description>
    </item>
    
    <item>
      <title>Unit Testing</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-e/</link>
      <pubDate>Mon, 16 Dec 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-e/</guid>
      <description>Testing code generation Bytecoder comes with built in JUnit Testing support using a specialized test runner. This test runner compiles the body of the test method to a target language and executes this code. For instance, the following JUnit Test
@RunWith(de.mirkosertic.bytecoder.unittest.BytecoderUnitTestRunner.class) public class SimpleMathTest { public static int sum(int a, int b) { return a + b; } @Test public void testAdd() throws Exception { int c = sum(10, 20); Assert.</description>
    </item>
    
    <item>
      <title>Extending the JRE</title>
      <link>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-g/</link>
      <pubDate>Fri, 25 Oct 2019 14:49:24 +0200</pubDate>
      
      <guid>https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-g/</guid>
      <description>Extending existing classes Sometimes the methods or properties you want aren&amp;rsquo;t there, but it&amp;rsquo;s very simple to add them.
public abstract class CustomCanvas extends de.mirkosertic.bytecoder.api.web.HTMLCanvasElement { // The following two methods are setters and getters for the canvas.width property. @de.mirkosertic.bytecoder.api.OpaqueProperty public abstract void width(float value); @de.mirkosertic.bytecoder.api.OpaqueProperty public abstract float width(); }  To use your custom methods or properties simply cast a HTMLCanvasElement to CustomCanvas.
((CustomCanvas) Window.window().document().getElementById(&amp;quot;canvas&amp;quot;)).width(1000);  Implementing bridges for JavaScript objects and classes Explanation of JavaScript data types in this page:</description>
    </item>
    
  </channel>
</rss>